vector
	增长为二倍增长
	capacity函数可以看到目前的容量大小
	
list
	list为双向链表
	forward_list为单向链表   //C++11
	
	#include<ext\slist>下的slist跟
	forward_list一模一样
	
	slist为GNU C中的
	每放一个数据就开辟一个元素大小的空间

	forward_list没有push_pack(),
	只有push_front();
	
	刻意在环状list尾端加一个空白节点, 以符合STL
	“前闭后开”区间
	
	iterator
		struct _List_node_base{
			_List_node_base* _M_next;
			_List_node_base* _M_prev;
		};
		template< typename _Tp>
		struct _List_node : public _List_node_base{
			_Tp _M_data;
		};
		template< typename _Tp, typename _Alloc = std::allocator<_Tp>>
		class list : protected _List_base< _Tp, _Alloc>{
		.....
		public:
			typedef __list_iterator< _Tp> iterator;
		.....
		};
		所有容器的iterator都要有下面5个typedef
		template< typename _Tp>
		struct __list_iterator {
			typedef __list_iterator< typename _Tp> self;
			typedef __list_node<_Tp>* link_type;
			typedef bidirectional_iterator_tag iterator_category;	//1
			typedef _Tp value_type;	//2
			typedef _Tp* pointer;	//3
			typedef _Tp& reference;	//4
			typedef ptrdiff_t difference_type;	//5
		.....
		};
	 
deque
	由一个个buffer构成，分段连续，
	每次增长一个buffer大小的空间
	
stack
	内部使用deque实现
queue
	内部使用deque实现
	
unordered_multiset
unordered_multimap
	bucket一定比元素多

unordered_multimap
	不能使用c[i]=value的方法插入value,
	map、multimap可以

BC++、VC++和GCC的allocator内部
	只用operator new和operator delete完成
	allocate()和deallocate(), 没有特殊设计 
	GCC2.9的alloc使用了较少的cookie, 使用方法:
	vector< Type, __gnu_cxx::__pool_alloc<Type>>
	
Algorithm
	Algorithm看不见Containers, 对其一无所知;
	它所需要的一切信息都要通过Iterator获得,
	而Iterator(由Containers提供)必须能够
	回答Algorithm的所有提问, 才能搭配该
	Algorithm的所有操作。 

Iterator需要遵循的原则:
	iterator是泛化的指针
	
	Iterator Traits必须有能力分辨class iterators和non-class iterators
	利用partial specialization可达到目标
		template<class I>
		struct iterator_traits {	//I是class iterator时
			typedef typename I::value_type value_type;	
		};
		//两个partial specialization:
		template<class T>
		struct iterator_traits<T*> {	//I是pointer to T时
			typedef T value_type;
		};
		template <class T>
		struct iterator_traits<const T*>{	//I是pointer to const T时
			typedef T value_type;	//注意是T而不是const T
			//value_type的主要目的是用来声明变量, 声明一个无法被赋值的
			//变量没有什么用, 所以iterator的value type不加上const
		};
		template<typename I, ...>
		void algorithm(...){
			typename iterator_traits<I>::value_type v1;
		}
	
	算法提出问题, iterator需要回答问题, 标准库有5种问题(4,5没出现过):
		1.category	2.distance	3.valueType
		4.reference	5.pointer
	
杂记
	除了array和vector以外, 所有容器的iterator
	都是class  
	所有容器内的元素都是前闭后开区间内
	
